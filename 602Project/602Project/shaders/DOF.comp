#version 460

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_GOOGLE_include_directive : enable

#include "shared_structs.h"

#define DOF_SINGLE_PIXEL_RADIUS 0.7071

const int GROUP_SIZE = 128;
layout(local_size_x = GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba32f) uniform image2D out_image_bg;
layout(set = 0, binding = 1, rgba32f) uniform image2D out_image_fg;
layout(set = 0, binding = 2, rgba32f) uniform image2D color_depth_buffer;
layout(set = 0, binding = 3, rgba32f) uniform image2D pre_params_buffer;
layout(set = 0, binding = 4, rgba32f) uniform image2D neighbour_max_buffer;
layout(set = 0, binding = 5, rgba32f) uniform image2D out_image;

layout(push_constant) uniform _pc_DOF { PushConstantDoF pc; };

float PI = 3.14159;

//The following function is from Shirley 1997
vec2 ToUnitDisk(vec2 onSquare) {
    float phi, r, u, v;
    float a = 2 * onSquare.x - 1;
    float b = 2 * onSquare.y - 1;

    if (a > -b) 
    {
        if (a > b)
        {
            r = a;
            phi = (PI/4) * (b/a);
        }
        else
        {
            r = b;
            phi = (PI/4) * (2 - (a/b));
        }
    }
    else
    {
        if (a < b)
        {
            r = -a;
            phi = (PI/4) * (4 + (b/a));
        }
        else
        {
            r = -b;
            if (b != 0)
                phi = (PI/4) * (6 - (a/b));
            else
                phi = 0;
        }
    }
    u = r * cos(phi);
    v = r * sin(phi);
    return vec2(u,v);
}

//The following equation is from Potmesil 1981
float CaclulateCoCDiameter(float depth) {
    float Cr = ((pc.lens_diameter * pc.focal_length) / (pc.focal_distance - pc.focal_length)) * 
                ( abs(depth - pc.focal_distance) / depth );
    return Cr * pc.coc_sample_scale;
}

float SpreadCompare(float offset_coc, float sample_coc) {
    return clamp(sample_coc - max(offset_coc - 1.0f, 0.0f), 0.0f, 1.0f);
}

float SampleAlpha(float sample_coc) {
    return min( 1.0f / (PI * sample_coc * sample_coc),
                1.0f / (PI * DOF_SINGLE_PIXEL_RADIUS * DOF_SINGLE_PIXEL_RADIUS));
}

void main()
{
    ivec2 gpos = ivec2(gl_GlobalInvocationID.xy);

    vec2 pixel_size = 1.0f / vec2(imageSize(color_depth_buffer));
    vec2 half_px = 0.5*pixel_size;

    int max_rings = 3;
    float coc_radius = imageLoad(neighbour_max_buffer, ivec2((gpos * 2)/pc.tile_size)).w / 2;

    vec4 out_color_bg = vec4(0.0f);
    vec4 out_color_fg = vec4(0.0f);
    int sample_count = 0;
    for (int i=1; i <=max_rings ; ++i ) {
        int taps = i*8;
        for (int j = 0; j <= taps ; j+=4) {
            for (int k = 0; k <= taps; k+=4) {
                float x = float(j) / taps;
                float y = float(k) / taps;
                vec2 circle_tap = ToUnitDisk(vec2(x, y));
                vec2 tap_pos = (float(i)/max_rings) * coc_radius * circle_tap;

                ivec2 load_pos = ivec2(vec2(gpos) + tap_pos + half_px);

                //Sample the params. 
                //Depth stored in the w component.
                vec4 sample_params = imageLoad(pre_params_buffer, load_pos);

                float spread_cmp = SpreadCompare(coc_radius, sample_params.r);

                //Foreground vs background classification
                float bg = sample_params.g * spread_cmp;
                float fg = sample_params.b * spread_cmp;
                bg = sample_params.g;
                fg = sample_params.b;
                
                vec3 sample_color = imageLoad(color_depth_buffer, load_pos).rgb;
                out_color_bg += max(bg, 0.0f) * vec4(sample_color, 1.0);
                out_color_fg += max(fg, 0.0f) * vec4(sample_color, 1.0);
                sample_count++;
            }
        }
    }
    float alpha = 
        clamp((2.0 * (1.0 / sample_count) * (1.0 / SampleAlpha(coc_radius)) * (out_color_fg.a)), 
               0.0f, 1.0f);
    vec3 out_color = mix(out_color_bg.rgb/out_color_bg.a, out_color_fg.rgb/out_color_fg.a, alpha);

    imageStore(out_image_bg, gpos, out_color_bg);
    imageStore(out_image_fg, gpos, out_color_fg);
    imageStore(out_image, gpos, vec4(out_color, alpha));
}
