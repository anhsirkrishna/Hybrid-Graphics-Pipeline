#version 460

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_GOOGLE_include_directive : enable

#include "shared_structs.h"

const int GROUP_SIZE = 128;
layout(local_size_x = GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba32f) uniform image2D out_image_bg;
layout(set = 0, binding = 1, rgba32f) uniform image2D out_image_fg;
layout(set = 0, binding = 2, rgba32f) uniform image2D color_buffer;
layout(set = 0, binding = 3, rgba32f) uniform image2D vel_depth_buffer;
layout(set = 0, binding = 4, rgba32f) uniform image2D neighbour_max_buffer;

layout(push_constant) uniform _pc_DOF { PushConstantDoF pc; };

float PI = 3.14159;

//The following function is from Shirley 1997
vec2 ToUnitDisk(vec2 onSquare) {
    float phi, r, u, v;
    float a = 2 * onSquare.x - 1;
    float b = 2 * onSquare.y - 1;

    if (a > -b) 
    {
        if (a > b)
        {
            r = a;
            phi = (PI/4) * (b/a);
        }
        else
        {
            r = b;
            phi = (PI/4) * (2 - (a/b));
        }
    }
    else
    {
        if (a < b)
        {
            r = -a;
            phi = (PI/4) * (4 + (b/a));
        }
        else
        {
            r = -b;
            if (b != 0)
                phi = (PI/4) * (6 - (a/b));
            else
                phi = 0;
        }
    }
    u = r * cos(phi);
    v = r * sin(phi);
    return vec2(u,v);
}

//The following equation is from Potmesil 1981
float CaclulateCoCDiameter(float depth) {
    float Cr = ((pc.lens_diameter * pc.focal_length) / (pc.focal_distance - pc.focal_length)) * 
                ( abs(depth - pc.focal_distance) / depth );
    return Cr * pc.coc_sample_scale;
}

//The following functions are from McGuire 2012
float softDepthCompare(float depth1, float depth2) {
    return clamp(1 - (depth1 - depth2) / pc.depth_scale_fg, 0, 1);
}

float cone(vec2 X, vec2 Y, float depth) {
    float coc_radius = CaclulateCoCDiameter(depth) / 2;
    return clamp(1 - length(X-Y)/coc_radius, 0, 1);
}

float cylinder(vec2 X, vec2 Y, float depth) {
    float coc_radius = CaclulateCoCDiameter(depth) / 2;
    return 1.0 - smoothstep(0.95f*coc_radius, 1.05f*coc_radius, length(X-Y));
}

void main()
{
    ivec2 gpos = ivec2(gl_GlobalInvocationID.xy);

    vec2 pixel_size = 1.0f / vec2(imageSize(color_buffer));
    vec2 half_px = 0.5*pixel_size;

    //Max Neighbourhood COC is stored in the w component of the NeighbourMax buffer
    float neighbour_coc = imageLoad(neighbour_max_buffer, ivec2(gpos/pc.tile_size)).w;
    
    //Current pixel color
    vec4 out_color = imageLoad(color_buffer, gpos);

    //Current velocity_depth
    vec4 curr_vel_depth = imageLoad(vel_depth_buffer, gpos);

    //Sample the current pixel
    float weight = 1 / curr_vel_depth.w;
    out_color *= weight;

    int max_rings = 3;
    float coc_radius = CaclulateCoCDiameter(curr_vel_depth.w) / 2;
    for (int i=1; i <=max_rings ; ++i ) {
        int taps = i*8;
        for (int j = 0; j <= taps ; j+=4) {
            for (int k = 0; k <= taps; k+=4) {
                if (j == k)
                    continue;

                float x = float(j) / taps;
                float y = float(k) / taps;
                vec2 circle_tap = ToUnitDisk(vec2(x, y));
                vec2 tap_pos = (float(i)/max_rings) * coc_radius * circle_tap;

                ivec2 load_pos = ivec2(vec2(gpos) + tap_pos + half_px);

                //Sample the depth. 
                //Depth stored in the w component.
                vec4 sample_vel_depth = imageLoad(vel_depth_buffer, load_pos);

                //Foreground vs background classification
                float fg = softDepthCompare(curr_vel_depth.w, sample_vel_depth.w);
                float bg = softDepthCompare(sample_vel_depth.w, curr_vel_depth.w);

                float alpha = (fg * cone(load_pos, gpos, curr_vel_depth.w)) +
                              (bg * cone(gpos, load_pos, sample_vel_depth.w)) +
                              (cylinder(load_pos, gpos, sample_vel_depth.w) * cylinder(gpos, load_pos, curr_vel_depth.w) * 2);

                weight += alpha;
                out_color += alpha * imageLoad(color_buffer, load_pos);
            }
        }
    }

    imageStore(out_image_bg, gpos, out_color / weight);
    imageStore(out_image_fg, gpos, vec4(0.0f, 0.0f, 1.0f, 0.0f));
}
